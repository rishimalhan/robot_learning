#!/usr/bin/env python3

import rospy
import time
import threading
import asyncio
from concurrent.futures import ThreadPoolExecutor
from moveit_commander import MoveGroupCommander, RobotCommander


class Executor:
    """
    Executor for robot motion plans.

    This class is responsible for executing motion plans generated by the Planner class.
    It includes functionality for verifying plans before execution and monitoring execution.
    """

    def __init__(self, move_group_name="manipulator"):
        """
        Initialize the executor with a specific move group.

        Args:
            move_group_name: Name of the MoveIt move group to use
        """
        self.robot = RobotCommander()
        self.move_group = MoveGroupCommander(move_group_name)
        self.group_name = move_group_name
        self._thread_executor = ThreadPoolExecutor(max_workers=1)
        self._execution_lock = threading.Lock()
        rospy.loginfo(f"Executor initialized for group: {move_group_name}")

    def execute_plan(self, plan, wait=True):
        """
        Execute a motion plan.

        Args:
            plan: Motion plan to execute
            verify_safety: Whether to check the plan for safety before execution
            wait: Whether to wait for the motion to complete

        Returns:
            bool: True if execution succeeded, False otherwise
        """
        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot execute empty plan")
            return False

        # Execute the plan
        rospy.loginfo(
            f"Executing trajectory with {len(plan.joint_trajectory.points)} waypoints"
        )

        try:
            start_time = time.time()
            execution_success = self.move_group.execute(plan, wait=wait)

            if wait:
                execution_time = time.time() - start_time
                if execution_success:
                    rospy.loginfo(
                        f"Execution completed successfully in {execution_time:.2f} seconds"
                    )
                else:
                    rospy.logerr(f"Execution failed after {execution_time:.2f} seconds")
            else:
                if execution_success:
                    rospy.loginfo("Execution started successfully")
                else:
                    rospy.logerr("Failed to start execution")

            return execution_success

        except Exception as e:
            rospy.logerr(f"Execution failed with error: {str(e)}")
            return False

    async def execute_plan_async(self, plan):
        """
        Execute a motion plan asynchronously using asyncio.

        Args:
            plan: Motion plan to execute

        Returns:
            asyncio.Future: Future that resolves to execution success (bool)
        """
        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot execute empty plan")
            return False

        rospy.loginfo(
            f"Executing trajectory asynchronously with {len(plan.joint_trajectory.points)} waypoints"
        )

        loop = asyncio.get_event_loop()

        # Use ThreadPoolExecutor to run the execution in a separate thread
        # This prevents blocking the asyncio event loop
        future = loop.run_in_executor(
            self._thread_executor, self._execute_plan_threadsafe, plan
        )

        return future

    def _execute_plan_threadsafe(self, plan):
        """
        Thread-safe execution of a plan, to be called from a ThreadPoolExecutor.

        Args:
            plan: Motion plan to execute

        Returns:
            bool: True if execution succeeded, False otherwise
        """
        with self._execution_lock:
            start_time = time.time()
            try:
                # Execute with wait=True to ensure the thread doesn't return until execution is complete
                execution_success = self.move_group.execute(plan, wait=True)
                execution_time = time.time() - start_time

                if execution_success:
                    rospy.loginfo(
                        f"Async execution completed successfully in {execution_time:.2f} seconds"
                    )
                else:
                    rospy.logerr(
                        f"Async execution failed after {execution_time:.2f} seconds"
                    )

                return execution_success
            except Exception as e:
                execution_time = time.time() - start_time
                rospy.logerr(
                    f"Async execution failed with error after {execution_time:.2f} seconds: {str(e)}"
                )
                return False

    def move_to_home(self, planner=None):
        """
        Move the robot to the home position.

        This method handles both planning and execution of the motion to home.
        If a planner is provided, it will be used for planning. Otherwise,
        this method assumes that planner functionality is already integrated
        with the move_group.

        Args:
            planner: An optional Planner instance to use for planning.
                    If None, uses the move_group directly.

        Returns:
            bool: True if the motion was successful, False otherwise.
        """
        rospy.loginfo("Moving to home position...")

        # Get available named targets
        named_targets = self.move_group.get_named_targets()

        # Check if we're using an external planner or direct move_group planning
        if planner:
            # Use the provided planner
            if "home" in named_targets:
                # Plan to the named target
                success, plan, planning_time, error_code = planner.plan_to_named_target(
                    "home"
                )
            else:
                # Plan to home
                success, plan, planning_time, error_code = planner.plan_to_home()

            if not success or not plan:
                rospy.logwarn("Failed to plan to home position")
                return False

            # Execute the plan
            return self.execute_plan(plan)
        else:
            # Plan and execute directly with move_group
            try:
                if "home" in named_targets:
                    self.move_group.set_named_target("home")
                    rospy.loginfo("Planning and moving to 'home' target")
                else:
                    # If no "home" target found, use the default home position
                    rospy.loginfo("No 'home' target found, using robot-specific home")
                    self.move_group.set_named_target("home")

                # Plan and execute in one go
                success = self.move_group.go(wait=True)

                # Report results
                if success:
                    rospy.loginfo("Successfully moved to home position")
                else:
                    rospy.logwarn("Failed to move to home position")

                return success

            except Exception as e:
                rospy.logerr(f"Error moving to home: {str(e)}")
                return False

    async def move_to_home_async(self, planner=None):
        """
        Move the robot to the home position asynchronously.

        Args:
            planner: An optional Planner instance to use for planning.
                   If None, uses the move_group directly.

        Returns:
            asyncio.Future: Future that resolves to execution success (bool)
        """
        rospy.loginfo("Moving to home position asynchronously...")

        # Get available named targets
        named_targets = self.move_group.get_named_targets()

        # Check if we're using an external planner
        if planner:
            # Use the provided planner
            if "home" in named_targets:
                # Plan to the named target
                success, plan, planning_time, error_code = planner.plan_to_named_target(
                    "home"
                )
            else:
                # Plan to home
                success, plan, planning_time, error_code = planner.plan_to_home()

            if not success or not plan:
                rospy.logwarn("Failed to plan to home position")
                return False

            # Execute the plan asynchronously
            return await self.execute_plan_async(plan)
        else:
            # For direct move_group planning, we still need to make it async
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                self._thread_executor, self._move_to_home_threadsafe
            )

    def _move_to_home_threadsafe(self):
        """Thread-safe implementation of moving to home position."""
        with self._execution_lock:
            try:
                named_targets = self.move_group.get_named_targets()
                if "home" in named_targets:
                    self.move_group.set_named_target("home")
                    rospy.loginfo("Planning and moving to 'home' target")
                else:
                    rospy.loginfo("No 'home' target found, using robot-specific home")
                    self.move_group.set_named_target("home")

                # Plan and execute in one go
                success = self.move_group.go(wait=True)

                # Report results
                if success:
                    rospy.loginfo("Successfully moved to home position")
                else:
                    rospy.logwarn("Failed to move to home position")

                return success

            except Exception as e:
                rospy.logerr(f"Error moving to home: {str(e)}")
                return False

    def stop_execution(self):
        """
        Stop any ongoing motion execution.

        Returns:
            bool: True if stopping succeeded, False otherwise
        """
        rospy.loginfo("Stopping robot motion execution")
        try:
            self.move_group.stop()
            return True
        except Exception as e:
            rospy.logerr(f"Failed to stop execution: {str(e)}")
            return False

    def clear_pose_targets(self):
        """Clear any pose targets that might be set."""
        self.move_group.clear_pose_targets()

    def clear_path_constraints(self):
        """Clear any path constraints that might be set."""
        self.move_group.clear_path_constraints()


if __name__ == "__main__":
    # Simple test if this file is run directly
    from core.planner import Planner
    import asyncio

    async def test_async_execution():
        planner = Planner()
        executor = Executor()

        # Test the async move_to_home functionality
        rospy.loginfo("Testing move_to_home_async with planner...")
        success = await executor.move_to_home_async(planner)

        if success:
            rospy.loginfo("Async move to home succeeded!")
        else:
            rospy.logerr("Async move to home failed!")

    rospy.init_node("executor_test", anonymous=True)

    # Run the async test
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test_async_execution())

    # Normal sync test for comparison
    planner = Planner()
    executor = Executor()

    rospy.loginfo("Testing synchronous move_to_home with planner...")
    success = executor.move_to_home(planner)

    if success:
        rospy.loginfo("Synchronous move to home succeeded!")
    else:
        rospy.logerr("Synchronous move to home failed!")

    rospy.spin()
