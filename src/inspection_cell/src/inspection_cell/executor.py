#!/usr/bin/env python3

import rospy
import time
from moveit_commander import MoveGroupCommander, RobotCommander
from inspection_cell.collision_checker import CollisionCheck
from moveit_msgs.msg import RobotTrajectory


class Executor:
    """
    Executor for robot motion plans.

    This class is responsible for executing motion plans generated by the Planner class.
    It includes functionality for verifying plans before execution and monitoring execution.
    """

    def __init__(self, move_group_name="manipulator", check_collisions=True):
        """
        Initialize the executor with a specific move group.

        Args:
            move_group_name: Name of the MoveIt move group to use
            check_collisions: Whether to check for collisions before execution
        """
        self.robot = RobotCommander()
        self.move_group = MoveGroupCommander(move_group_name)
        self.group_name = move_group_name
        self.check_collisions = check_collisions

        # Initialize collision checker if needed
        if check_collisions:
            self.collision_checker = CollisionCheck(move_group_name=move_group_name)
            rospy.loginfo("Collision checker initialized for execution safety checks")

        rospy.loginfo(f"Executor initialized for group: {move_group_name}")

    def check_plan_safety(self, plan):
        """
        Check if a motion plan is safe to execute (collision-free).

        Args:
            plan: Motion plan to check

        Returns:
            bool: True if the plan is safe, False otherwise
        """
        if not self.check_collisions:
            rospy.loginfo("Collision checking is disabled, skipping safety check")
            return True

        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot check safety of empty plan")
            return False

        # Check trajectory points for collisions
        rospy.loginfo(
            f"Checking safety of trajectory with {len(plan.joint_trajectory.points)} points"
        )

        # For efficiency, check only a subset of points for longer trajectories
        points = plan.joint_trajectory.points
        if len(points) > 10:
            # Skip points to check approximately 10 points evenly spaced
            step = len(points) // 10
            points_to_check = [points[i] for i in range(0, len(points), step)]
            points_to_check.append(points[-1])  # Always check the final point
        else:
            points_to_check = points

        # Check each selected point
        for i, point in enumerate(points_to_check):
            joint_positions = list(point.positions)
            is_valid = self.collision_checker.check_state_validity(joint_positions)
            if not is_valid:
                rospy.logwarn(f"Trajectory point {i} is in collision!")
                rospy.logwarn(self.collision_checker.get_collision_report())
                return False

        rospy.loginfo("Trajectory passed safety check")
        return True

    def execute_plan(self, plan, verify_safety=True, wait=True):
        """
        Execute a motion plan.

        Args:
            plan: Motion plan to execute
            verify_safety: Whether to check the plan for safety before execution
            wait: Whether to wait for the motion to complete

        Returns:
            bool: True if execution succeeded, False otherwise
        """
        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot execute empty plan")
            return False

        # Check plan safety if requested
        if verify_safety and self.check_collisions:
            if not self.check_plan_safety(plan):
                rospy.logerr("Plan failed safety check, aborting execution")
                return False

        # Execute the plan
        rospy.loginfo(
            f"Executing trajectory with {len(plan.joint_trajectory.points)} waypoints"
        )

        try:
            start_time = time.time()
            execution_success = self.move_group.execute(plan, wait=wait)

            if wait:
                execution_time = time.time() - start_time
                if execution_success:
                    rospy.loginfo(
                        f"Execution completed successfully in {execution_time:.2f} seconds"
                    )
                else:
                    rospy.logerr(f"Execution failed after {execution_time:.2f} seconds")
            else:
                if execution_success:
                    rospy.loginfo("Execution started successfully")
                else:
                    rospy.logerr("Failed to start execution")

            return execution_success

        except Exception as e:
            rospy.logerr(f"Execution failed with error: {str(e)}")
            return False

    def stop_execution(self):
        """
        Stop any ongoing motion execution.

        Returns:
            bool: True if stopping succeeded, False otherwise
        """
        rospy.loginfo("Stopping robot motion execution")
        try:
            self.move_group.stop()
            return True
        except Exception as e:
            rospy.logerr(f"Failed to stop execution: {str(e)}")
            return False

    def clear_pose_targets(self):
        """Clear any pose targets that might be set."""
        self.move_group.clear_pose_targets()

    def clear_path_constraints(self):
        """Clear any path constraints that might be set."""
        self.move_group.clear_path_constraints()


if __name__ == "__main__":
    # Simple test if this file is run directly
    from inspection_cell.planner import Planner

    rospy.init_node("executor_test", anonymous=True)

    planner = Planner()
    executor = Executor()

    # Plan and execute a motion to the home position
    success, plan, planning_time, error_code = planner.plan_to_home()

    if success:
        rospy.loginfo("Planning succeeded, executing...")
        execution_success = executor.execute_plan(plan)
        if execution_success:
            rospy.loginfo("Execution succeeded!")
        else:
            rospy.logerr("Execution failed!")
    else:
        rospy.logerr("Planning failed!")

    rospy.spin()
