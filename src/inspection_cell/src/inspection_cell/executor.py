#!/usr/bin/env python3

import rospy
import time
from moveit_commander import MoveGroupCommander, RobotCommander
from inspection_cell.collision_checker import CollisionCheck
from moveit_msgs.msg import RobotTrajectory


class Executor:
    """
    Executor for robot motion plans.

    This class is responsible for executing motion plans generated by the Planner class.
    It includes functionality for verifying plans before execution and monitoring execution.
    """

    def __init__(self, move_group_name="manipulator"):
        """
        Initialize the executor with a specific move group.

        Args:
            move_group_name: Name of the MoveIt move group to use
        """
        self.robot = RobotCommander()
        self.move_group = MoveGroupCommander(move_group_name)
        self.group_name = move_group_name
        rospy.loginfo(f"Executor initialized for group: {move_group_name}")

    def execute_plan(self, plan, wait=True):
        """
        Execute a motion plan.

        Args:
            plan: Motion plan to execute
            verify_safety: Whether to check the plan for safety before execution
            wait: Whether to wait for the motion to complete

        Returns:
            bool: True if execution succeeded, False otherwise
        """
        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot execute empty plan")
            return False

        # Execute the plan
        rospy.loginfo(
            f"Executing trajectory with {len(plan.joint_trajectory.points)} waypoints"
        )

        try:
            start_time = time.time()
            execution_success = self.move_group.execute(plan, wait=wait)

            if wait:
                execution_time = time.time() - start_time
                if execution_success:
                    rospy.loginfo(
                        f"Execution completed successfully in {execution_time:.2f} seconds"
                    )
                else:
                    rospy.logerr(f"Execution failed after {execution_time:.2f} seconds")
            else:
                if execution_success:
                    rospy.loginfo("Execution started successfully")
                else:
                    rospy.logerr("Failed to start execution")

            return execution_success

        except Exception as e:
            rospy.logerr(f"Execution failed with error: {str(e)}")
            return False

    def move_to_home(self, planner=None):
        """
        Move the robot to the home position.

        This method handles both planning and execution of the motion to home.
        If a planner is provided, it will be used for planning. Otherwise,
        this method assumes that planner functionality is already integrated
        with the move_group.

        Args:
            planner: An optional Planner instance to use for planning.
                    If None, uses the move_group directly.

        Returns:
            bool: True if the motion was successful, False otherwise.
        """
        rospy.loginfo("Moving to home position...")

        # Get available named targets
        named_targets = self.move_group.get_named_targets()

        # Check if we're using an external planner or direct move_group planning
        if planner:
            # Use the provided planner
            if "home" in named_targets:
                # Plan to the named target
                success, plan, planning_time, error_code = planner.plan_to_named_target(
                    "home"
                )
            else:
                # Plan to home
                success, plan, planning_time, error_code = planner.plan_to_home()

            if not success or not plan:
                rospy.logwarn("Failed to plan to home position")
                return False

            # Execute the plan
            return self.execute_plan(plan)
        else:
            # Plan and execute directly with move_group
            try:
                if "home" in named_targets:
                    self.move_group.set_named_target("home")
                    rospy.loginfo("Planning and moving to 'home' target")
                else:
                    # If no "home" target available, use the default home position
                    rospy.loginfo("No 'home' target found, using robot-specific home")
                    self.move_group.set_named_target("home")

                # Plan and execute in one go
                success = self.move_group.go(wait=True)

                # Report results
                if success:
                    rospy.loginfo("Successfully moved to home position")
                else:
                    rospy.logwarn("Failed to move to home position")

                return success

            except Exception as e:
                rospy.logerr(f"Error moving to home: {str(e)}")
                return False

    def stop_execution(self):
        """
        Stop any ongoing motion execution.

        Returns:
            bool: True if stopping succeeded, False otherwise
        """
        rospy.loginfo("Stopping robot motion execution")
        try:
            self.move_group.stop()
            return True
        except Exception as e:
            rospy.logerr(f"Failed to stop execution: {str(e)}")
            return False

    def clear_pose_targets(self):
        """Clear any pose targets that might be set."""
        self.move_group.clear_pose_targets()

    def clear_path_constraints(self):
        """Clear any path constraints that might be set."""
        self.move_group.clear_path_constraints()


if __name__ == "__main__":
    # Simple test if this file is run directly
    from inspection_cell.planner import Planner

    rospy.init_node("executor_test", anonymous=True)

    planner = Planner()
    executor = Executor()

    # Test the move_to_home functionality
    rospy.loginfo("Testing move_to_home with planner...")
    success = executor.move_to_home(planner)

    if success:
        rospy.loginfo("Move to home succeeded!")
    else:
        rospy.logerr("Move to home failed!")

    rospy.spin()
