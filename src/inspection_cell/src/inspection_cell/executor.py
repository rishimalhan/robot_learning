#!/usr/bin/env python3

import rospy
import time
from moveit_commander import MoveGroupCommander, RobotCommander
from inspection_cell.collision_checker import CollisionCheck
from moveit_msgs.msg import RobotTrajectory


class Executor:
    """
    Executor for robot motion plans.

    This class is responsible for executing motion plans generated by the Planner class.
    It includes functionality for verifying plans before execution and monitoring execution.
    """

    def __init__(self, move_group_name="manipulator"):
        """
        Initialize the executor with a specific move group.

        Args:
            move_group_name: Name of the MoveIt move group to use
        """
        self.robot = RobotCommander()
        self.move_group = MoveGroupCommander(move_group_name)
        self.group_name = move_group_name
        rospy.loginfo(f"Executor initialized for group: {move_group_name}")

    def execute_plan(self, plan, wait=True):
        """
        Execute a motion plan.

        Args:
            plan: Motion plan to execute
            verify_safety: Whether to check the plan for safety before execution
            wait: Whether to wait for the motion to complete

        Returns:
            bool: True if execution succeeded, False otherwise
        """
        if not plan or not plan.joint_trajectory.points:
            rospy.logerr("Cannot execute empty plan")
            return False

        # Execute the plan
        rospy.loginfo(
            f"Executing trajectory with {len(plan.joint_trajectory.points)} waypoints"
        )

        try:
            start_time = time.time()
            execution_success = self.move_group.execute(plan, wait=wait)

            if wait:
                execution_time = time.time() - start_time
                if execution_success:
                    rospy.loginfo(
                        f"Execution completed successfully in {execution_time:.2f} seconds"
                    )
                else:
                    rospy.logerr(f"Execution failed after {execution_time:.2f} seconds")
            else:
                if execution_success:
                    rospy.loginfo("Execution started successfully")
                else:
                    rospy.logerr("Failed to start execution")

            return execution_success

        except Exception as e:
            rospy.logerr(f"Execution failed with error: {str(e)}")
            return False

    def stop_execution(self):
        """
        Stop any ongoing motion execution.

        Returns:
            bool: True if stopping succeeded, False otherwise
        """
        rospy.loginfo("Stopping robot motion execution")
        try:
            self.move_group.stop()
            return True
        except Exception as e:
            rospy.logerr(f"Failed to stop execution: {str(e)}")
            return False

    def clear_pose_targets(self):
        """Clear any pose targets that might be set."""
        self.move_group.clear_pose_targets()

    def clear_path_constraints(self):
        """Clear any path constraints that might be set."""
        self.move_group.clear_path_constraints()


if __name__ == "__main__":
    # Simple test if this file is run directly
    from inspection_cell.planner import Planner

    rospy.init_node("executor_test", anonymous=True)

    planner = Planner()
    executor = Executor()

    # Plan and execute a motion to the home position
    success, plan, planning_time, error_code = planner.plan_to_home()

    if success:
        rospy.loginfo("Planning succeeded, executing...")
        execution_success = executor.execute_plan(plan)
        if execution_success:
            rospy.loginfo("Execution succeeded!")
        else:
            rospy.logerr("Execution failed!")
    else:
        rospy.logerr("Planning failed!")

    rospy.spin()
